<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL设置远程访问服务器]]></title>
    <url>%2F2018%2F07%2F19%2FMySQL%E8%AE%BE%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[由于工作中需要进行远程登录MySQL服务器，在查阅了相关资料后，总结了一下如何对MySQL进行设置远程访问服务器。在MySQL里面，root用户只允许本地连接。为了考虑安全性，我们需要设置一个远程登录的账户。 配置mysqld.cnf文件不同的linux版本，这个文件的位置不同。以ubuntu14为例： 该文件位置为 /etc/mysql/my.cnf以ubuntu18为例： 该文件位置为 /etc/mysql/mysql.conf.d/mysqld.cnf编辑该文件，将 bind-address = 127.0.0.1 用#注释起来。 建一个远程账户用root账户登录mysql : #mysql -uroot -pmysql&gt; GRANT ALL ON *.* TO admin@&#39;%&#39; IDENTIFIED BY &#39;xxxx&#39; WITH GRANT OPTION;这句话的意思 ，允许任何IP地址（上面的 % 就是这个意思）的电脑 用admin帐户 和密码（xxxx）来访问这个MySQL Server 刷新权限#flush privileges; 重新启动mysql服务#service mysql restart]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【shell脚本学习指南】第二章-入门]]></title>
    <url>%2F2018%2F07%2F17%2F%E3%80%90shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[2.3 一个简单的脚本创建一个脚本，实现计算在当前系统上用户的个数123456$ cat &gt; nusers # 建立文件，使用cat复制终端的输入who | wc -l # 程序的内容^D # Ctrl-D 表示end-of-file$ chmod +x nusers # 让文件拥有执行的权限$ ./nusers # 执行测试 6 # 输出我们想要的结果 2.5.3 简单的echo输出echo 在输出一行字符串的时候，会在末尾自动加入一个换行符，在许多的版本中，echo看到第一个参数为 -n 时，会省略结尾的换行符号，例如：1234root@us1804 echo "Enter your name "Enter your name root@us1804 echo -n "Enter your name "Enter your name root@us1804 2.5.4 华丽的printf输出printf命令模仿了C程序库里的printf()库程序。printf命令与echo命令最大的不同在于，printf不会像echo那样能够自动的提供一个换行符，必须要显示的指定换行符号\n。 printf命令的完整语法分为两部分：1printf format-string [arguments ...] 第一部分是一个字符串，包含按字面显示的字符和格式声明。第二部分是与格式声明相对于的参数列表，常用的格式声明有两个：%s 和 %d。其中%s用于字符串，%d用于十进制整数； 例如，%s用于字符串的输出：123root@us1804 printf "The first program always prints %s,%s! \n" Hello worldThe first program always prints Hello,word! root@us1804 2.5.5.1 重定向与管道以 &lt; 改变标准输入 ：1tr -d '\r' &lt; dos-file.txt 以 &gt; 改变标准输出 ：1tr -d '\r' &lt; dos-file.txt &gt; UNIX-file.txt 以上这条命令会先以tr将dos-file.txt里的ASCII carriage-return（回车）删除，再将转换完成的数据输出到UNIX-file.txt。dos-file.txt里的原始数据不会有变化。 以 &gt;&gt; 附加到文件 12345678910111213141516171819tr 命令详解 :Usage: tr [OPTION]... SET1 [SET2]Translate, squeeze, and/or delete characters from standard input,writing to standard output.-c, -C, --complement use the complement of SET1将标准输入中的字符不在SET1中的内容，都替换为SET2中的字符 -d, --delete delete characters in SET1, do not translate -s, --squeeze-repeats replace each sequence of a repeated character that is listed in the last specified SET, with a single occurrence of that character 浓缩重复的字符，如果标准输入中有连续出现的SET1里面的字符，则将其浓缩为一个。如果有SET2参数，则代表浓缩为一个后替换为SET2所示参数。-t, --truncate-set1 first truncate SET1 to length of SET2将标准输入中的SET1中的内容替换为SET2中的内容，替换的内容为从SET1开始等字符长度替换。 2.5.5.2 特殊文件： /dev/null 和 /dev/tty/dev/null,就是位桶（bit bucket）. 传送到此文件的数据都会被系统丢掉。如果你需要的是命令的退出状态，而非它的输入，此功能会很有用。 /dev/tty当程序打开此文件时，UNIX会自动将它重定向到一个终端或串行端口。例如下脚本：12345678#!/bin/bashprintf "Enter new password:\n" # 提示输入stty -echo # 关闭自动打印输入字符的功能，打开输入的终端read pass &lt; /dev/tty # 读取密码printf "Enter again:\n" # 提示再输入一次read pass2 &lt; /dev/tty # 再读取一次以确认stty echo # 打开自动打印输入字符的功能,关闭输入的终端 2.5.6 基本命令查找Shell会沿着查找路径$PATH来寻址命令。$PATH是一个以冒号分隔的目录列表，可以在列表所指定的目录下找到所要执行的命令。 查看当前的默认路径：12echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin 如果你想编写自己的脚本，最好准备自己的bin目录来存放它们，并且让Shell能够自动找到它们。做法为建立自己的bin目录，并将它加入$PATH中的列表即可:123456root@us1804: cd # 切换到home目录root@us1804: mkdir bin # 建立个人bin目录root@us1804: mv nusers bin # 将我们的脚本置入该目录root@us1804: PATH=$PATH:$HOME/bin # 将个人的bin目录附加到PATHroot@us1804: nusers # 试试看root@us1804: 6 # Shell有找到它并执行 若要让修改永久生效，在.profile文件中把你的bin目录加入$PATH,而每次登陆时Shell都将读取.profile文件。$PAHT里的空项目表示当前目录。例如:1/usr/local/sbin::/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin 2.6 访问Shell脚本的参数在执行Shell脚本的时候可以附加参数，也就是命令行参数。基于历史原因，当参数的个数超过9个的时候，就应该用大括号把数字框起来，例如：12echo first arg is $1echo tench arg is $&#123;10&#125; 2.7 简单的执行跟踪程序是人写的，难免会出错。如果想知道你的程序在做什么，有个好方法，就是把执行跟踪的功能打开。这会使得Shell显示每个被执行到的命令，并在前面加上”+”:一个加号后面跟着一个空格。例如：1234sh -x nusers # 打开执行跟踪功能+ who # 被跟踪的功能+ wc -l 7 # 实际的输出]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【shell脚本】操作MySQL数据库相关脚本]]></title>
    <url>%2F2018%2F07%2F15%2F%E3%80%90shell%E8%84%9A%E6%9C%AC%E3%80%91%E5%A4%87%E4%BB%BD%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[备份整个库的脚本： 123456789101112131415#!/bin/bashBACKUP_HOST=hostBACKUP_USER=userBACKUP_PASSWORD=passwdBACKUP_PORT=3306BACKUP_DB=dbbak_date=`date -d today +"%Y%m%d"` bak_path="/back/mysql/audit_2_54/$bak_date" for table_name in `echo "show tables;" | mysql -u$BACKUP_USER -p$BACKUP_PASSWORD -h$BACKUP_HOST -P$BACKUP_PORT $BACKUP_DB | grep -v Tables`;do mysqldump -h$BACKUP_HOST -u$BACKUP_USER -p$BACKUP_PASSWORD -P$BACKUP_PORT --single-transaction --verbose --default-character-set=utf8 $BACKUP_DB $table_name | gzip &gt; $&#123;bak_path&#125;/BAK_"$table_name".sql.gzdone 备份库里面的部分表的脚本，需要借助外部文件存储要备份的部分表名： 1234567891011121314151617#!/bin/bashBACKUP_HOST=hostBACKUP_USER=userBACKUP_PASSWORD=passwdBACKUP_PORT=3306BACKUP_DB=dbbak_date=`date -d today +"%Y%m%d"` bak_path="/back/mysql/audit_2_54/$bak_date" mkdir -pv $bak_pathfor table_name in `cat /back/mysql/audit_2_54/shell/bak.log`do mysqldump -h$BACKUP_HOST -u$BACKUP_USER -p$BACKUP_PASSWORD -P$BACKUP_PORT --single-transaction --verbose --default-character-set=utf8 $BACKUP_DB $table_name | gzip &gt; $&#123;bak_path&#125;/BAK_"$table_name".sql.gzdone 删除库里部分表的脚本： 1234567891011121314#!/bin/bashBACKUP_HOST=hostBACKUP_USER=userBACKUP_PASSWORD=passwdBACKUP_PORT=3306BACKUP_DB=dbfor table_name in `cat /root/audit_temp_del/del.log`do delSqlStr="DROP TABLE $table_name " #删除表的SQL语句 mysql -u$DEL_USER -p$DEL_PASSWORD -h$DEL_HOST -P$DEL_PORT $DEL_DB -e "$delSqlStr" #执行SQL语句done 获取某个库里面的所有表的表名、表名注释、字段名、字段名注释信息 12345678910111213#!/bin/bash# 获取指定数据库里面的所有表名，表名注释，字段名，字段名注释touch information.sqlfor table_name in `echo "show tables;" | mysql -uroot -proot -hlocalhost -P3306 audit | grep -v Tables`;do sqlStr1="Select table_name 表名,TABLE_COMMENT 表注释 from INFORMATION_SCHEMA.TABLES Where table_schema='audit' and table_name='$table_name';" mysql -uroot -proot -hlocalhost -P3306 audit -e "$sqlStr1" &gt;&gt; test # 执行SQL语句 sqlStr2="select COLUMN_NAME 字段,COLUMN_COMMENT 字段注释 from INFORMATION_SCHEMA.COLUMNS where TABLE_SCHEMA='audit' and TABLE_NAME='$table_name';" mysql -uroot -proot -hlocalhost -P3306 audit -e "$sqlStr2" | grep -v 字段 &gt;&gt; test # 执行SQL语句done]]></content>
      <categories>
        <category>【shell脚本】</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【shell脚本】逐行处理文本文件]]></title>
    <url>%2F2018%2F07%2F15%2F%E3%80%90shell%E8%84%9A%E6%9C%AC%E3%80%91%E9%80%90%E8%A1%8C%E5%A4%84%E7%90%86%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1.通过read命令完成 read命令接收标准输入，或其他文件描述符的输入，得到输入后，read命令将数据放入一个标准变量中。 利用read读取文件时，每次调用read命令都会读取文件中的”一行”文本。 当文件没有可读的行时，read命令将以非零状态退出。1234567891011# 第一种方式 cat data.dat | while read line do echo "File:$&#123;line&#125;" done # 第二种方式 while read line do echo "File:$&#123;line&#125;" done &lt; data.dat 2.使用awk命令完成 awk是一种优良的文本处理工具，提供了极其强大的功能。 利用awk读取文件中的每行数据，并且可以对每行数据做一些处理，还可以单独处理每行数据里的每列数据。 12cat data.dat | awk '&#123;print $0&#125;'cat data.dat | awk '&#123;for(i=2;i&lt;NF;i++) &#123;printf $i&#125; printf "\n"&#125;' 第1行代码输出data.dat里的每行数据，第2代码输出每行中从第2列之后的数据。如果是单纯的数据或文本文件的按行读取和显示的话，使用awk命令比较方便。 3.使用for var in file 命令完成 for var in file 表示变量var在file中循环取值，取值的分隔符由$IFS确定。 1234567891011# 方案一 for line in $(cat data.dat) do echo "File:$&#123;line&#125;" done # 方案二 for line in `cat data.dat` do echo "File:$&#123;line&#125;" done 如果输入文本每行中没有空格，则line在输入文本中按换行符分隔符循环取值。 如果输入文本中包括空格或制表符，则不是换行读取，line在输入文本中按空格分隔符或制表符或换行符特环取值。 可以通过把IFS设置为换行符来达到逐行读取的功能。 IFS的默认值为：空白(包括：空格，制表符，换行符)。]]></content>
      <categories>
        <category>【shell脚本】</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java遍历删除list中的元素]]></title>
    <url>%2F2018%2F07%2F08%2FJava%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4list%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[JAVA中循环遍历list有三种方式for循环、增强for循环（也就是常说的foreach循环）、iterator遍历。 for循环遍历list1234for (int i=0; i&lt;list.size(); i++) &#123; if (list.get(i).equals("del")) list.remove(i);&#125; 这种方式的问题在于，删除某个元素后，list的大小发生了变化，而你的索引也在变化，所以会导致你在遍历的时候漏掉某些元素。比如当你删除第1个元素后，继续根据索引访问第2个元素时，因为删除的关系后面的元素都往前移动了一位，所以实际访问的是第3个元素。因此，这种方式可以用在删除特定的一个元素时使用，但不适合循环删除多个元素时使用。 对于for循环遍历list的解决办法123456for (int i=0; i&lt;list.size(); i++)&#123; if (list.get(i).equals("del")) &#123; list.remove(i); i--; &#125;&#125; 增强for循环1234for(String x:list)&#123; if(x.equals("del")) list.remove(x);&#125; 这种方式的问题在于，删除元素后继续循环会报错误信息ConcurrentModificationException，因为元素在使用的时候发生了并发的修改，导致异常抛出。但是删除完毕马上使用break跳出，则不会触发报错。 iterator遍历1234567Iterator&lt;String&gt; it = list.iterator();while(it.hasNext())&#123; String x = it.next(); if(x.equals("del"))&#123; it.remove(); &#125;&#125; 这种方式可以正常的循环及删除。但要注意的是，使用iterator的remove方法，如果用list的remove方法同样会报上面提到的ConcurrentModificationException错误。 总结：（1）循环删除list中特定一个元素的，可以使用三种方式中的任意一种，但在使用中要注意上面分析的各个问题。 （2）循环删除list中多个元素的，应该使用迭代器iterator方式。或则for循环的修改版本。]]></content>
      <tags>
        <tag>java</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA获取当前时间的前一天或者前几天时间]]></title>
    <url>%2F2018%2F07%2F08%2FJAVA%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E7%9A%84%E5%89%8D%E4%B8%80%E5%A4%A9%E6%88%96%E8%80%85%E5%89%8D%E5%87%A0%E5%A4%A9%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[方案一：老方法，不推荐使用1234SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");// 获取前一天的时间Date date=new Date(new Date().getTime()-24*60*60*1000);System.out.println(sdf.format(date)); 方案二：推荐使用12345678910SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date date=new Date(); Calendar calendar = Calendar.getInstance(); calendar.setTime(date); // 获取前一天的时间calendar.add(Calendar.DATE, -1);// 获取后一天的时间calendar.add(Calendar.DATE, 1);date = calendar.getTime(); System.out.println(sdf.format(date));]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
